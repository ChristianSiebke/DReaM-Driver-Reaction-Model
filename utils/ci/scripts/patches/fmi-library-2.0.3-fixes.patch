diff --git a/src/Import/src/FMI1/fmi1_import_capi.c b/src/Import/src/FMI1/fmi1_import_capi.c
index 842c998..807cdae 100644
--- a/src/Import/src/FMI1/fmi1_import_capi.c
+++ b/src/Import/src/FMI1/fmi1_import_capi.c
@@ -67,18 +67,8 @@ jm_status_enu_t fmi1_import_create_dllfmu(fmi1_import_t* fmu, fmi1_callback_func
 		return jm_status_error;
 	}
 
-	if(jm_portability_set_current_working_directory(dllDirPath) != jm_status_success) {
-		jm_log_fatal(fmu->callbacks, module, "Could not change to the DLL directory %s", dllDirPath);
-		if(ENOENT == errno)
-			jm_log_fatal(fmu->callbacks, module, "The FMU contains no binary for this platform.");
-		else
-			jm_log_fatal(fmu->callbacks, module, "System error: %s", strerror(errno));
-	}
-	else {
-		/* Allocate memory for the C-API struct */
-		fmu -> capi = fmi1_capi_create_dllfmu(fmu->callbacks, dllFileName, modelIdentifier, callBackFunctions, standard);
-	}
-
+	/* Allocate memory for the C-API struct */
+	fmu -> capi = fmi1_capi_create_dllfmu(fmu->callbacks, dllFileName, modelIdentifier, callBackFunctions, standard);
 
 	/* Load the DLL handle */
 	if (fmu -> capi) {
diff --git a/src/Import/src/FMI2/fmi2_import_capi.c b/src/Import/src/FMI2/fmi2_import_capi.c
index e794775..a2a68ba 100644
--- a/src/Import/src/FMI2/fmi2_import_capi.c
+++ b/src/Import/src/FMI2/fmi2_import_capi.c
@@ -88,18 +88,8 @@ jm_status_enu_t fmi2_import_create_dllfmu(fmi2_import_t* fmu, fmi2_fmu_kind_enu_
 		callBackFunctions = &defaultCallbacks;
 	}
 
-	if(jm_portability_set_current_working_directory(dllDirPath) != jm_status_success) {
-		jm_log_fatal(fmu->callbacks, module, "Could not change to the DLL directory %s", dllDirPath);
-		if(ENOENT == errno)
-			jm_log_fatal(fmu->callbacks, module, "The FMU contains no binary for this platform.");
-		else
-			jm_log_fatal(fmu->callbacks, module, "System error: %s", strerror(errno));
-	}
-	else {
-		/* Allocate memory for the C-API struct */
-		fmu -> capi = fmi2_capi_create_dllfmu(fmu->callbacks, dllFileName, modelIdentifier, callBackFunctions, fmuKind);
-	}
-
+	/* Allocate memory for the C-API struct */
+	fmu -> capi = fmi2_capi_create_dllfmu(fmu->callbacks, dllFileName, modelIdentifier, callBackFunctions, fmuKind);
 
 	/* Load the DLL handle */
 	if (fmu -> capi) {
diff --git a/src/Util/include/JM/jm_portability.h b/src/Util/include/JM/jm_portability.h
index 82e472a..605dff9 100644
--- a/src/Util/include/JM/jm_portability.h
+++ b/src/Util/include/JM/jm_portability.h
@@ -11,61 +11,62 @@
 
     You should have received a copy of the FMILIB_License.txt file
     along with this program. If not, contact Modelon AB <http://www.modelon.com>.
-*/
-
-#ifndef JM_PORTABILITY_H_
-#define JM_PORTABILITY_H_
-#include <fmilib_config.h>
-#include "jm_callbacks.h"
-
-/* Include platform dependent headers */
-#if defined(_MSC_VER) || defined(WIN32) || defined(__MINGW32__)
-#include <windows.h> /* Microsoft Windows API */
-#define DLL_HANDLE HANDLE
-#else
-#define DLL_HANDLE void*
-#include <dlfcn.h>  /* Standard POSIX/UNIX API */
-#endif
-
-#include "jm_types.h"
-/** \file jm_portability.h
-	Handling platform specific defines and functions.
-*/
-/**
-	\addtogroup jm_utils
-	@{
-		\addtogroup jm_portability
-	@}
-*/
-/** \addtogroup jm_portability Handling platform specific defines and functions
-@{*/
-/** \brief Load a dll/so library into the process and return a handle. */
-DLL_HANDLE		jm_portability_load_dll_handle		(const char* dll_file_path);
-
-/** \brief Unload a Dll and release the handle*/
-jm_status_enu_t jm_portability_free_dll_handle		(DLL_HANDLE dll_handle);
-
+*/
+
+#ifndef JM_PORTABILITY_H_
+#define JM_PORTABILITY_H_
+#include <fmilib_config.h>
+#include "jm_callbacks.h"
+
+/* Include platform dependent headers */
+#if defined(_MSC_VER) || defined(WIN32) || defined(__MINGW32__)
+#include <windows.h> /* Microsoft Windows API */
+#define DLL_HANDLE HANDLE
+#else
+#define DLL_HANDLE void*
+#include <dlfcn.h>  /* Standard POSIX/UNIX API */
+#endif
+
+#include "jm_types.h"
+/** \file jm_portability.h
+	Handling platform specific defines and functions.
+*/
+/**
+	\addtogroup jm_utils
+	@{
+		\addtogroup jm_portability
+	@}
+*/
+/** \addtogroup jm_portability Handling platform specific defines and functions
+@{*/
+/** \brief Load a dll/so library into the process and return a handle. */
+DLL_HANDLE		jm_portability_load_dll_handle		(const char* dll_file_path);
+
+/** \brief Unload a Dll and release the handle*/
+jm_status_enu_t jm_portability_free_dll_handle		(DLL_HANDLE dll_handle);
+
 /** \brief A function pointer as returned when DLL symbol is loaded.*/
-#ifdef WIN32
-#define jm_dll_function_ptr FARPROC
-#else
-typedef void* jm_dll_function_ptr; 
-#endif
-
-/** \brief Find a function in the Dll and return a function pointer */
-jm_status_enu_t jm_portability_load_dll_function	(DLL_HANDLE dll_handle, char* dll_function_name, jm_dll_function_ptr* dll_function_ptrptr);
-
-/** \brief Return error associated with Dll handling */
-char* jm_portability_get_last_dll_error	(void);
-
-/** \brief Get current working directory name */
-jm_status_enu_t jm_portability_get_current_working_directory(char* buffer, size_t len);
-
-/** \brief Set current working directory*/
-jm_status_enu_t jm_portability_set_current_working_directory(const char* cwd);
-
-/** \brief Get system-wide temporary directory */
-const char* jm_get_system_temp_dir();
+#ifdef WIN32
+#define jm_dll_function_ptr FARPROC
+#else
+typedef void* jm_dll_function_ptr; 
+#endif
+
+/** \brief Find a function in the Dll and return a function pointer */
+jm_status_enu_t jm_portability_load_dll_function	(DLL_HANDLE dll_handle, char* dll_function_name, jm_dll_function_ptr* dll_function_ptrptr);
+
+/** \brief Return error associated with Dll handling */
+char* jm_portability_get_last_dll_error	(void);
+
+/** \brief Get current working directory name */
+jm_status_enu_t jm_portability_get_current_working_directory(char* buffer, size_t len);
+
+/** \brief Set current working directory*/
+jm_status_enu_t jm_portability_set_current_working_directory(const char* cwd);
+
+/** \brief Get system-wide temporary directory */
+FMILIB_EXPORT
+const char* jm_get_system_temp_dir();
 
 /**
     \brief Create a uniquely named temporary directory.
@@ -79,66 +80,67 @@ const char* jm_get_system_temp_dir();
 */
 char *jm_mkdtemp(jm_callbacks *cb, char *tmplt);
 
-
-/** 
-	\brief Get absolute path to an existing directory
-	\param cb - callbacks for memory allocation and logging. Default callbacks are used if this parameter is NULL.
-	\param dir - path to a directory (relative or absolute).
-	\param outPath - buffer for storing the directory
-	\param len - of the buffer (if size is larger than FILENAME_MAX + 1 then the path will always fit in)
-	\return Pointer to outPath on success, 0 - on error in which case a message is send to the logger.	
-*/
-char* jm_get_dir_abspath(jm_callbacks* cb, const char* dir, char* outPath, size_t len);
-
-/** 
-	\brief Create a unique temporary directory
-	\param cb - callbacks for memory allocation and logging. Default callbacks are used if this parameter is NULL.
-	\param systemTempDir - directory where the temp dir should be located both absolute and relative path are accepted.
-				System-wide directory is used if this parameter is NULL.
-	\param tempPrefix - File name template prefix used when creating temporaty directories. "jm" is used if this is NULL.
-	\return A pointer to the temporary directory name (absolute path, no terminating '/'). Caller is responsible for freeing the memory.
-		The function returns NULL if there were errors in which case a message is send to the logger.	
-*/
-char* jm_mk_temp_dir(jm_callbacks* cb, const char* systemTempDir, const char* tempPrefix);
-
-/** 
-	\brief Create a file:// URL from absolute path
-	\param cb - callbacks for memory allocation and logging. Default callbacks are used if this parameter is NULL.
-	\param absPath - absolute path to be converted into the URL
-	\return A pointer to the URL. Caller is responsible for freeing the memory.
-		The function returns NULL if there were errors in which case a message is send to the logger.	
-*/
-char* jm_create_URL_from_abs_path(jm_callbacks* cb, const char* absPath);
-
-/**
-	\brief Make a directory.
-*/
-jm_status_enu_t jm_mkdir(jm_callbacks* cb, const char* dir);
-
-/**
-\brief Remove directory and all it contents.
-*/
-jm_status_enu_t jm_rmdir(jm_callbacks* cb, const char* dir);
-
-/**
-\brief C89 compatible implementation of C99 vsnprintf. 
-*/
+
+/** 
+	\brief Get absolute path to an existing directory
+	\param cb - callbacks for memory allocation and logging. Default callbacks are used if this parameter is NULL.
+	\param dir - path to a directory (relative or absolute).
+	\param outPath - buffer for storing the directory
+	\param len - of the buffer (if size is larger than FILENAME_MAX + 1 then the path will always fit in)
+	\return Pointer to outPath on success, 0 - on error in which case a message is send to the logger.	
+*/
+char* jm_get_dir_abspath(jm_callbacks* cb, const char* dir, char* outPath, size_t len);
+
+/** 
+	\brief Create a unique temporary directory
+	\param cb - callbacks for memory allocation and logging. Default callbacks are used if this parameter is NULL.
+	\param systemTempDir - directory where the temp dir should be located both absolute and relative path are accepted.
+				System-wide directory is used if this parameter is NULL.
+	\param tempPrefix - File name template prefix used when creating temporaty directories. "jm" is used if this is NULL.
+	\return A pointer to the temporary directory name (absolute path, no terminating '/'). Caller is responsible for freeing the memory.
+		The function returns NULL if there were errors in which case a message is send to the logger.	
+*/
+char* jm_mk_temp_dir(jm_callbacks* cb, const char* systemTempDir, const char* tempPrefix);
+
+/** 
+	\brief Create a file:// URL from absolute path
+	\param cb - callbacks for memory allocation and logging. Default callbacks are used if this parameter is NULL.
+	\param absPath - absolute path to be converted into the URL
+	\return A pointer to the URL. Caller is responsible for freeing the memory.
+		The function returns NULL if there were errors in which case a message is send to the logger.	
+*/
+char* jm_create_URL_from_abs_path(jm_callbacks* cb, const char* absPath);
+
+/**
+	\brief Make a directory.
+*/
+jm_status_enu_t jm_mkdir(jm_callbacks* cb, const char* dir);
+
+/**
+\brief Remove directory and all it contents.
+*/
+FMILIB_EXPORT
+jm_status_enu_t jm_rmdir(jm_callbacks* cb, const char* dir);
+
+/**
+\brief C89 compatible implementation of C99 vsnprintf. 
+*/
 FMILIB_EXPORT
 int jm_vsnprintf(char * str, size_t size, const char * fmt, va_list al);
 
-/**
-\brief C89 compatible implementation of C99 snprintf. 
-*/
-FMILIB_EXPORT
+/**
+\brief C89 compatible implementation of C99 snprintf. 
+*/
+FMILIB_EXPORT
 int jm_snprintf(char * str, size_t size, const char * fmt, ...);
-
+
 #ifdef HAVE_VA_COPY
 #define JM_VA_COPY va_copy
-#elif defined(HAVE___VA_COPY)
+#elif defined(HAVE___VA_COPY)
 #define JM_VA_COPY __va_copy
 #elif defined(WIN32)
 #define JM_VA_COPY(dest,src) dest=src
 #endif
-
-/*@}*/
-#endif /* End of header file JM_PORTABILITY_H_ */
+
+/*@}*/
+#endif /* End of header file JM_PORTABILITY_H_ */
